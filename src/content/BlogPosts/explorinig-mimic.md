---
title: "Explorinig Mimic"
date: "2025-11-25"
excerpt: "Placeholder entry for an upcoming post on Mimic."
tags: ["Placeholder"]
---

I found out about mimic, a cross-chain automation layer, at DevConnect BA. I was referred by someone from Uniswap Cup who I approached after this Telegram chat message in the Uniswap Cup team chat where all the team players were added and we were randomly discussing cleat length, ball size, and other nonsense:

![the notorious Telegram message](/images/notorious-tg-message.png)

Pandit reached out to me and recommended to contact Lucasz from [mimic.fi] who quickly gave me a rundown of their 3 layer architecture. It kinda clicked right off the bat considering my 3 year long DeFi journey. Smart contract development and deployment tooling is to say lightly not so friendly for an average dev coming from a conventional Web2 background like me.

![the notorious Telegram message](/images/Rashid-and-Lukasz.png)

So after a 40-minute crash course given to me by Lukasz [todo: embed X post], I figured: why not try it myself? Mimic sounded like the kind of abstraction layer that could dramatically speed up “time-to-chain” for common on-chain workflows. I started by building a simple task—the core unit you define in Mimic—and decided to automate a USD-threshold-based token transfer to see how the whole flow works end-to-end. The tooling is pleasantly straightforward, powered by the @mimicprotocol/cli package and built with Oclif for a clean developer experience. You can install it globally for convenience:

```bash
yarn global add @mimicprotocol/cli
```

```bash
❯ mimic --version
@mimicprotocol/cli/0.0.1-rc.27 linux-x64 node-v24.11.0
```

![Mimic demo](/images/mimic.gif)

### Here's my approach

Initialize the project.

Define the manifest (inputs, ABIs, metadata).

Implement the task logic.

Build to validate, generate artifacts, and compile.

Deploy the output to the task registry for relayers.

### Initialize the project

Let's start a new working directory to develop your task. To do that you can run the following command:

```bash
mimic init -d my-mimic-task
```

![Mimic demo](/images/creating-mimic-task.gif)

That generates a simple `manifest.yaml`:

```yaml
version: 1.0.0
name: Example Task
description: Autogenerated example task
inputs:
  - chainId: uint32
  - token: address
  - amount: uint256
  - recipient: address
  - maxFee: uint256
```

This is essentially the configuration of the task. You describe the task in a declarative way and the system will bring it to the desired state. Love the idea - it reminds me of the reasons I switched from Arch Linux to NixOS. I was sick of packages breaking my setup and endless configuration drift (NixOS still breaks, but I can roll back with a single command).

Ok I digress, sorry. Let's define an automated task that checks an account’s USD-denominated balance for a specific ERC-20 token, and if that balance falls below a given USD threshold, it triggers a token transfer (with a specified amount, recipient, and max fee) on the given chain.

Compared to the base config, we add a new input called `thresholdUsd` and switch the numeric fields (`amount`, `maxFee`) to strings so they can accept human-readable decimals. With these additions, the task can now check the token’s USD value and only execute the transfer when the account’s USD-denominated balance drops below the specified threshold.

```yaml
version: 1.0.0
name: Transfer based on USD threshold
description: Automated task to execute parameterized transfers based on balance threshold in USD
inputs:
  - chainId: uint32
  - token: address
  - amount: string # e.g., '10.2' = 10.2 of the given token
  - recipient: address
  - maxFee: string # e.g., '0.01' = 0.01 of the given token
  - thresholdUsd: string # e.g., '30.5' = 30.5 USD
abis:
  - ERC20: ./abis/ERC20.json
```

I had to provide [ERC20 abi](https://216358192-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F2K6E4Us9xYRIC0Tt0SIZ%2Fuploads%2FLzvR464ArklTLEA67qfw%2FERC20.json?alt=media&token=163296d8-8fd0-4376-a649-4c7c07f8b321) in `./abis/ERC20.json`

Let's validate the manifest definitions and generate the corresponding code to access both, your declared inputs and the contract ojects for your declared ABIs.

run:

```bash
mimic codegen
```

This command will output the generated types to `./src/types` by default. It will also assume your manifest file is called `manifest.yaml`.

### Let's write the task logic

The task logic is implemented in AssemblyScript and must export:

Input type: The generated inputs type from the previous step.

Main function: The core task logic, which receives the inputs as an argument.

Create a file ./src/task.ts and implement the logic:

```typescript
import {
  BigInt,
  ERC20Token,
  log,
  TokenAmount,
  Transfer,
  USD,
} from "@mimicprotocol/lib-ts";

import { ERC20 } from "./types/ERC20";
import { inputs } from "./types";

export default function main(): void {
  const tokenContract = new ERC20(inputs.token, inputs.chainId);
  const balance = tokenContract.balanceOf(inputs.recipient);

  const token = ERC20Token.fromAddress(inputs.token, inputs.chainId);
  const balanceInUsd = TokenAmount.fromBigInt(token, balance).toUsd();
  const thresholdUsd = USD.fromStringDecimal(inputs.thresholdUsd);
  log.info(`Balance in USD: ${balanceInUsd}`);

  if (balanceInUsd.lt(thresholdUsd)) {
    const amount = BigInt.fromStringDecimal(inputs.amount, token.decimals);
    const maxFee = BigInt.fromStringDecimal(inputs.maxFee, token.decimals);
    Transfer.create(token, amount, inputs.recipient, maxFee).send();
  }
}
```

As you can see, the generated contract artifacts can be accessed from your task code.

For now Mimic tasks allows creating three types of intents:

- Transfers
- kGeneric calls
- Cross-chain swaps

### Time to compile

The compile process converts your task logic and manifest into deployable artifacts:

build/task.wasm - Compiled WebAssembly binary

build/manifest.json - Processed manifest configuration

Run the compile command:

```bash
mimic compile
```

Here is an example of the output produced by this command:

```
build/
├── task.wasm         # Compiled WASM binary
├── manifest.json     # Validated manifest
```

### Time to deploy

This is where you upload your task artifacts to the network so others can discover it. To do this you can run the deploy command using the CLI:
mimic deploy --key [DEPLOYMENT_KEY]

```bash
mimic deploy --key [DEPLOYMENT_KEY]
```

You can generate a deployment key from the explorer app, where you can login using your wallet.

By default, this command will run code generation and compilation, then deploy the generated artifacts from the build directory. You can skip the build steps by passing --skip-compile if you already have up-to-date artifacts.

You can specify a different input/output directory using the following parameters:

```bash
mimic deploy --input build --output build
```

This command will upload your artifacts to the Mimic Registry (which stores them on IPFS) and pin the resultant CID so it can be discovered by others. The CID is also written to CID.json in the specified output directory.

### Time to configure our task

After deploying your task, you can now configure it to tell which config relayers should use to run your task. This means defining the parameters declared in your manifest.yml file. This configuration is done in the [explorer UI](https://protocol.mimic.fi/api-key) where you will be requested to sign your config with your wallet.

Open the explorer and locate the task you just deployed under the tasks section.

Add or edit your config parameters

Sign the new config

This signature ensures relayers know the config is authorized by the task owner.

You can update or deprecate this config at any point in time to reflect changes, without needing to redeploy the task code again. Just sign the new config in the explorer, and relayers will pick up the latest version.

_Follow them on_

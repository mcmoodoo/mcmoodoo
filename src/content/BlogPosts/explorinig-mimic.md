---
title: "Explorinig Mimic"
date: "2025-11-25"
excerpt: "Placeholder entry for an upcoming post on Mimic."
tags: ["Placeholder"]
---

I found out about mimic, a cross-chain automation layer, at DevConnect BA. I was referred by someone from Uniswap Cup who I approached after this Telegram chat message in the Uniswap Cup team chat where all the team players were added and we were randomly discussing cleat length, ball size, and other nonsense:

![the notorious Telegram message](/images/notorious-tg-message.png)

Pandit reached out to me and recommended to contact Lucasz from [mimic.fi] who quickly gave me a rundown of their 3 layer architecture. It kinda clicked right off the bat considering my 3 year long DeFi journey. Smart contract development and deployment tooling is to say lightly not so friendly for an average dev coming from a conventional Web2 background like me.

![After a 40-minute crash course on mimic given by Lukasz](/images/Rashid-and-Lukasz.png)
[todo: embed X post]

So after a 40-minute crash course given to me by Lukasz, I figured: why not try it myself? Mimic sounded like the kind of abstraction layer that could dramatically speed up “time-to-chain” for common on-chain workflows. I started by building a simple task—the core unit you define in Mimic—and decided to automate a USD-threshold-based token transfer to see how the whole flow works end-to-end. The tooling is pleasantly straightforward, powered by the @mimicprotocol/cli package and built with Oclif for a clean developer experience. You can install it globally for convenience:

```bash
yarn global add @mimicprotocol/cli
```

```bash
❯ mimic --version
@mimicprotocol/cli/0.0.1-rc.27 linux-x64 node-v24.11.0
```

![Mimic demo](/images/mimic.gif)

### Here's my approach

Initialize the project.

Define the manifest (inputs, ABIs, metadata).

Implement the task logic.

Build to validate, generate artifacts, and compile.

Deploy the output to the task registry for relayers.

### Initialize the project

Let's start a new working directory to develop your task. To do that you can run the following command:

```bash
mimic init -d token-transfer
```

![Mimic demo](/images/creating-mimic-task.gif)

That generates a simple `manifest.yaml`:

```yaml
version: 1.0.0
name: Example Task
description: Autogenerated example task
inputs:
  - chainId: uint32
  - token: address
  - amount: uint256
  - recipient: address
  - maxFee: uint256
```

The manifest file is the blueprint of the task I’m building. It describes the task to Mimic in a clean, declarative way—its name, inputs, and contract dependencies. It acts as the task’s schema, and the tooling uses it to type-check the logic, generate bindings, and package the final task.

So, you describe the task in a declarative way and Mimic will "manifest" it to the desired state. Love the idea - it reminds me of the reasons I switched from Arch Linux to NixOS. I was sick of packages breaking my setup and endless configuration drift (NixOS still breaks, but I can roll back with a single command).

Ok I digress, sorry. Let's define an automated task that checks an account’s USD-denominated balance for a specific ERC-20 token, and if that balance falls below a given USD threshold, it triggers a token transfer (with a specified amount, recipient, and max fee) on the given chain.

Compared to the base config, we add a new input called `thresholdUsd` and switch the numeric fields (`amount`, `maxFee`) to strings so they can accept human-readable decimals. With these additions, the task can now check the token’s USD value and only execute the transfer when the account’s USD-denominated balance drops below the specified threshold.

```diff
 version: 1.0.0
-name: Example Task
-description: Autogenerated example task
+name: Transfer based on USD threshold
+description: Automated task to execute parameterized transfers based on balance threshold in USD
 inputs:
   - chainId: uint32
   - token: address
-  - amount: string          # e.g., '20.5' = 20.5 of the given token
+  - amount: string # e.g., '10.2' = 10.2 of the given token
   - recipient: address
-  - maxFee: string          # e.g., '0.01' = 0.01 of the given token
+  - maxFee: string # e.g., '0.01' = 0.01 of the given token
+  - thresholdUsd: string # e.g., '30.5' = 30.5 USD
+abis:
+  - ERC20: ./abis/ERC20.json
```

I had to provide [ERC20 abi](https://216358192-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F2K6E4Us9xYRIC0Tt0SIZ%2Fuploads%2FLzvR464ArklTLEA67qfw%2FERC20.json?alt=media&token=163296d8-8fd0-4376-a649-4c7c07f8b321) in `./abis/ERC20.json`

Let's validate the manifest definitions and generate the corresponding code to access both, your declared inputs and the contract ojects for your declared ABIs.

run:

```bash
mimic codegen
```

It just generates these files which are ignored by git anyway:

```
❯ tree src/types/
src/types/
├── ERC20.ts
└── index.ts

1 directory, 2 files
```

This command will output the generated types to `./src/types` by default. It will also assume your manifest file is called `manifest.yaml`.

### Let's write the task logic

The task logic is implemented in AssemblyScript and must export:

Input type: The generated inputs type from the previous step.

Main function: The core task logic, which receives the inputs as an argument.

So now we get to the meat of it all - creating a task! The task is defined in the magical `./src/task.ts` file.

So I just grabbed an example code from [mimic's tutorial](https://docs.mimic.fi/examples/build-a-simple-task)

```diff
+import {
+  log,
+  TokenAmount,
+  USD,
+} from "@mimicprotocol/lib-ts";

+import { ERC20 } from "./types/ERC20";

 export default function main(): void {
-  const amount = BigInt.fromStringDecimal(inputs.amount, token.decimals)
-  const maxFee = BigInt.fromStringDecimal(inputs.maxFee, token.decimals)
-  Transfer.create(token, amount, inputs.recipient, maxFee).send()
+  const tokenContract = new ERC20(inputs.token, inputs.chainId);
+  const balance = tokenContract.balanceOf(inputs.recipient);
+
+  const balanceInUsd = TokenAmount.fromBigInt(token, balance).toUsd();
+  const thresholdUsd = USD.fromStringDecimal(inputs.thresholdUsd);
+  log.info(`Balance in USD: ${balanceInUsd}`);
+
+  if (balanceInUsd.lt(thresholdUsd)) {
+    const amount = BigInt.fromStringDecimal(inputs.amount, token.decimals);
+    const maxFee = BigInt.fromStringDecimal(inputs.maxFee, token.decimals);
+    Transfer.create(token, amount, inputs.recipient, maxFee).send();
+  }
 }
```

### Time to compile

The compile process converts your task logic and manifest into deployable artifacts:

build/task.wasm - Compiled WebAssembly binary

build/manifest.json - Processed manifest configuration

So, I decided to compile in a very confident way:

```bash
mimic compile
```

![Compiling](/images/mimic-compile.gif)

Here's what it produces:

```
build/
├── task.wasm         # Compiled WASM binary
├── manifest.json     # Validated manifest
```

### Time to deploy

This is where you upload your task artifacts to the network so others can discover it. To do this you can run the deploy command using the CLI:

```bash
mimic deploy --key [DEPLOYMENT_KEY]
```

![Deploying artifacts](/images/mimic-deploy.gif)

It deploys and stores the artifacts on IPFS https://ipfs.io/ipfs/QmSTBXXP2CjzRkxSYew9YPKU2m2qcUbvdyveUiqvQvoLZX/
This command will upload your artifacts to the Mimic Registry (which stores them on IPFS) and pin the resultant CID so it can be discovered by others.

![Artifacts stored on IPFS](/images/mimic-deployment-ipfs.png)

Next I headed to <a href="https://protocol.mimic.fi/api-key" target="_blank" rel="noopener noreferrer">explorer app ↗</a> to genearate a deployment key:

![Trying to get thet deployment key from the explorer app](/images/generating-deployment-key.png)

and after a quick login with my wallet, I was thrown to my dashboard with an API key generated for me already:

![Mimic dashboard](/images/mimic-dashboard.png)

By default, this command will run code generation and compilation, then deploy the generated artifacts from the build directory. You can skip the build steps by passing --skip-compile if you already have up-to-date artifacts.

### Time to configure our task

After deploying your task, you can now configure it to tell which config relayers should use to run your task. This means defining the parameters declared in your manifest.yml file. This configuration is done in the [explorer UI](https://protocol.mimic.fi/api-key) where you will be requested to sign your config with your wallet.

Open the explorer and locate the task you just deployed under the tasks section.

Add or edit your config parameters

Sign the new config

This signature ensures relayers know the config is authorized by the task owner.

You can update or deprecate this config at any point in time to reflect changes, without needing to redeploy the task code again. Just sign the new config in the explorer, and relayers will pick up the latest version.

## Possible enhancements

- Add completions to the mimic cli. I felt unnecessary friction when typing out all the commands by hand without the ability to use tab completion.
- In the docs, the links with northeast arrows are misleading. I thought they would open in a new tab, but instead it changed the current page. I often lost the original tutorial and had to come back to the mimic site, then click on docs, then find that tutorial again.
  ![Misleading northeast arrow next to a link](/images/misleading-northeast-arrow.png)
- more visuals and less text in the docs (at least in the guides and tutorials)
- a video walkthrough would have been helpful as a primer before the tutorial
- more concise text in the docs to save developers time when ploughing through the docs

_Follow them on_
